4. When the JMPC field in a microinstruction is enabled, MBR is ORed with NEXT AD-
DRESS to form the address of the next microinstruction. Are there any circumstances
in which it makes sense to have NEXT ADDRESS be 0x1FF and use JMPC?

Max MBR Value = 0x0FF (8bits)
NEXT_ADDRESS = 0x1FF

0x000 || 0x1FF = 0x1FF
0x001 || 0x1FF = 0x1FF
0x002 || 0x1FF = 0x1FF [...]
0x0FF || 0x1FF = 0x1FF

No. If NEXT_ADDRESS = 0x1FF, any MBR value will result 0x1FF.

5. Suppose that in the example of Fig. 4-14(a) the statement
k = 5; 
is added after the if statement. What would the new assembly code be? Assume that
the compiler is an optimizing compiler.

i = j + k;
if (i == 3)
    k = 5;
    k = 0;
else
    j = j − 1;

ILOAD j                         // i = j + k 0x15 0x02
ILOAD k 0x15 0x03
IADD 0x60
ISTORE i 0x36 0x01
ILOAD i                         // if (i == 3) 0x15 0x01
BIPUSH 3 0x10 0x03
IF ICMPEQ L1 0x9F 0x00 0x0D
ILOAD j                         // j = j − 1 0x15 0x02
BIPUSH 1 0x10 0x01
ISUB 0x64
ISTORE j 0x36 0x02
GOTO L2 0xA7 0x00 0x07
L1: BIPUSH 0                    // k = 0 0x10 0x00
ISTORE k 0x36 0x03
L2:

In a optimized compiler, the new assembly code will be the same, because new statement is overwritten by k = 0;

6. Give two different IJVM translations for the following Java statement:

i = k + n + 5;

ILOAD k
ILOAD n
IADD
BIPUSH 0x5
IADD
ISTORE i

BIPUSH 0x5
ILOAD n
ILOAD k
IADD
IADD
ISTORE i

7. Give the Java statement that produced the following IJVM code:
ILOAD j
ILOAD n
ISUB
BIPUSH 7
ISUB
DUP
IADD
ISTORE i

STACK:

                        n           7                       j-n-7           
            j           j           j-n         j-n         i-n-7       j-n-7       2(j*n*7)
            1           2           3           4           5           6           7           8

i = 2 * (j*n*7);

8. In the text we mentioned that when translating the statement
if (Z) goto L1; else goto L2
to binary, L2 has to be in the bottom 256 words of the control store. Would it not be
equally possible to have L1 at, say, 0x40 and L2 at 0x140? Explain your answer.

if (Z) goto L1; else goto L2

No. L2 = 0x140, will imply in a leap of 320 bytes. 

9. In the microprogram for Mic-1, in if_icmpeq3, MDR is copied to H. A few lines later it
is subtracted from TOS to check for equality. Surely it is better to have one statement:
if_cmpeq3 Z = TOS − MDR; rd
Why is this not done?

Because it's needed to change TOS value, after copy MDR to H, and before subtracted it from TOS

10. How long does a 2.5-GHz Mic-1 take to execute the following Java statement
i = j + k; 
Give your answer in nanoseconds.

ILOAD j -> 5 + 1
ILOAD k -> 5 + 1
IADD -> 3 + 1
ISTORE i -> 6 + 1

27 cycles.

1 cycle = 0.4 nanoseconds

27 cycles = 10.8 nanoseconds

11. Repeat the previous question, only now for a 2.5-GHz Mic-2. Based on this calcula-
tion, how long would a program that runs for 100 sec on the Mic-1 take on the Mic-2?

ILOAD j -> 3 + 1
ILOAD k -> 3 + 1
IADD -> 3 + 1
ISTORE i -> 5 + 1

18 cycles.

1 cycle = 0.4 nanoseconds

18 cycles = 7.2 nanoseconds

ratio: 10.8 / 7.2 = 1.5

A program that runs for 100 sec on Mic-1 will take 66.666 seconds on Mic-2

12. Write microcode for the Mic-1 to implement the JVM POPTWO instruction. This in-
struction removes two words from the top of the stack.

POP

MAR -> Memory Address Register
SP -> Stack Pointer
TOS -> Top of Stack
MDR -> Memory Data Register

POP:

pop1:   MAR = SP = SP - 1; rd        /// Read in netx-to-top word on stack
pop2:                                /// Wait for read
pop3:   TOS = MDR; goto(MBR1)        /// Copy new word to TOS

POPTWO:

poptwo1:    MAR = SP = SP - 1;
poptwo3:    MAR = SP = SP - 1; rd        /// Read in netx-to-top word on stack
poptwo4:                                /// Wait for read
poptwo5:    TOS = MDR; goto(MBR1)        /// Copy new word to TOS

poptwo1:    MAR = SP = SP -1; goto(POP)


13. On the full JVM machine, there are special 1-byte opcodes for loading locals 0 through
3 onto the stack instead of using the general ILOAD instruction. How should IJVM be
modified to make the best use of these instructions?

14. The instruction ISHR (arithmetic shift right integer) exists in JVM but not in IJVM. It
uses the top two values on the stack, replacing them with a single value, the result.
The second-from-top word of the stack is the operand to be shifted. Its content is
shifted right by a value between 0 and 31, inclusive, depending on the value of the 5
least significant bits of the top word on the stack (the other 27 bits of the top word are
ignored). The sign bit is replicated to the right for as many bits as the shift count. The
opcode for ISHR is 122 (0x7A).

a. What is the arithmetic operation equivalent to left shift with a count of 2?

0x10000000 = 128

0x10000000 << 2 = 0x1000000000 = 256

Double the value.

b. Extend the microcode to include this instruction as a part of IJVM.

ishr1 goto(istore1)
ishr2 goto(istore1)

15. The instruction ISHL (shift left integer) exists in JVM but not in IJVM. It uses the top
two values on the stack, replacing the two with a single value, the result. The sec-
ond-from-top word of the stack is the operand to be shifted. Its content is shifted left
by a value between 0 and 31, inclusive, depending on the value of the 5 least signifi-
cant bits of the top word on the stack (the other 27 bits of the top word are ignored).
Zeros are shifted in from the right for as many bits as the shift count. The opcode for
ISHL is 120 (0x78).

a. What is the arithmetic operation equivalent to shifting left with a count of 2?

0x10000000 = 128

0x10000000 >> 2 = 0x100000 = 64

half the value

b. Extend the microcode to include this instruction as a part of IJVM.

ishr1 goto(istore1)
ishr2 goto(istore1)

16. The JVM INVOKEVIRTUAL instruction needs to know how many parameters it has.
Why?

Because to start the execution of the invoked method, the program counter needs to 
be pointed after method parameters.

